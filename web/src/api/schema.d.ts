/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Health Check */
        get: operations["health_check_api_health_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Jobs
         * @description List all jobs (oldest first, FIFO order).
         */
        get: operations["list_jobs_api_jobs_get"];
        put?: never;
        /**
         * Create Job
         * @description Create a new sync job.
         *
         *     Jobs are queued and executed sequentially. Returns 409 if queue is full.
         */
        post: operations["create_job_api_jobs_post"];
        /**
         * Clear Jobs
         * @description Clear all completed/failed/cancelled jobs.
         *
         *     Running and queued jobs are not affected.
         */
        delete: operations["clear_jobs_api_jobs_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/{job_id}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cancel Job
         * @description Cancel a running or queued job.
         */
        post: operations["cancel_job_api_jobs__job_id__cancel_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/{job_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete Job
         * @description Delete a completed, failed, or cancelled job.
         *
         *     Running or queued jobs cannot be deleted.
         */
        delete: operations["delete_job_api_jobs__job_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/logs/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get buffered log entries
         * @description Returns all currently buffered log entries as an array.
         */
        get: operations["get_log_history_api_logs_history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/logs/sse": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Stream structured logs via SSE
         * @description Each SSE data line contains a JSON-serialized LogEntry object.
         */
        get: operations["stream_logs_api_logs_sse_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/cookies/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Cookies Status
         * @description Check if cookies file is configured.
         */
        get: operations["cookies_status_api_cookies_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/cookies": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Upload Cookies
         * @description Upload cookies.txt content (Netscape format).
         *
         *     The cookie file enables downloading from private playlists
         *     and accessing age-restricted content on YouTube Music.
         */
        post: operations["upload_cookies_api_cookies_post"];
        /**
         * Delete Cookies
         * @description Delete the cookies file.
         */
        delete: operations["delete_cookies_api_cookies_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sync/playlists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Playlists
         * @description List all synced playlists.
         */
        get: operations["list_playlists_api_sync_playlists_get"];
        put?: never;
        /**
         * Add Playlist
         * @description Add a playlist for syncing.
         *
         *     Returns 409 Conflict if the URL is already registered.
         */
        post: operations["add_playlist_api_sync_playlists_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sync/playlists/{playlist_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Playlist
         * @description Get a single synced playlist.
         */
        get: operations["get_playlist_api_sync_playlists__playlist_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Playlist
         * @description Remove a playlist from syncing.
         */
        delete: operations["delete_playlist_api_sync_playlists__playlist_id__delete"];
        options?: never;
        head?: never;
        /**
         * Update Playlist
         * @description Update a synced playlist's name or enabled status.
         */
        patch: operations["update_playlist_api_sync_playlists__playlist_id__patch"];
        trace?: never;
    };
    "/sync/playlists/{playlist_id}/sync": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Sync Playlist
         * @description Create a sync job for a specific playlist.
         *
         *     Returns 404 if playlist not found, 409 if queue is full.
         */
        post: operations["sync_playlist_api_sync_playlists__playlist_id__sync_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sync/run": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Sync All
         * @description Create sync jobs for all enabled playlists.
         */
        post: operations["sync_all_api_sync_run_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sync/config": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Config
         * @description Get sync configuration.
         */
        get: operations["get_config_api_sync_config_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Config
         * @description Update sync configuration.
         */
        patch: operations["update_config_api_sync_config_patch"];
        trace?: never;
    };
    "/sync/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Status
         * @description Get scheduler status and summary.
         */
        get: operations["get_status_api_sync_status_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AddPlaylistRequest
         * @description Request to add a playlist for syncing.
         */
        AddPlaylistRequest: {
            /**
             * Url
             * @description YouTube or YouTube Music playlist URL
             * @example https://music.youtube.com/playlist?list=OLAK5uy_...
             */
            url: string;
            /**
             * Name
             * @description Display name for the playlist
             */
            name: string;
        };
        /**
         * AddPlaylistResponse
         * @description Response when a playlist is added.
         */
        AddPlaylistResponse: {
            /** Id */
            id: string;
            /**
             * Message
             * @default Playlist added
             */
            message: string;
        };
        /**
         * AudioCodec
         * @description Supported audio output codecs.
         * @enum {string}
         */
        AudioCodec: "opus" | "mp3" | "m4a";
        /**
         * CancelJobResponse
         * @description Response when a job is cancelled.
         */
        CancelJobResponse: {
            /**
             * Message
             * @default Job cancelled
             * @constant
             */
            message: "Job cancelled";
        };
        /**
         * ClearJobsResponse
         * @description Response when jobs are cleared.
         */
        ClearJobsResponse: {
            /** Cleared */
            cleared: number;
        };
        /**
         * ContentInfo
         * @description Information about downloaded content (album, playlist, or track).
         */
        ContentInfo: {
            /** Title */
            title: string;
            /** Artist */
            artist: string;
            /** Year */
            year?: number | null;
            /** Track Count */
            track_count: number;
            /**
             * Playlist Id
             * @default
             */
            playlist_id: string;
            /**
             * Url
             * @default
             */
            url: string;
            /** Thumbnail Url */
            thumbnail_url?: string | null;
            /** Audio Codec */
            audio_codec?: string | null;
            /** Audio Bitrate */
            audio_bitrate?: number | null;
            /** @default playlist */
            kind: components["schemas"]["ContentKind"];
        };
        /**
         * ContentKind
         * @description Type of music content (album vs playlist vs track).
         * @enum {string}
         */
        ContentKind: "album" | "playlist" | "track";
        /**
         * CookiesStatusResponse
         * @description Cookies status response model.
         */
        CookiesStatusResponse: {
            /** Configured */
            configured: boolean;
        };
        /**
         * CookiesUploadRequest
         * @description Cookies upload request model.
         */
        CookiesUploadRequest: {
            /** Content */
            content: string;
        };
        /**
         * CookiesUploadResponse
         * @description Cookies upload response model.
         */
        CookiesUploadResponse: {
            /**
             * Status
             * @constant
             */
            status: "ok";
        };
        /**
         * CreateJobRequest
         * @description Request to create a new sync job.
         */
        CreateJobRequest: {
            /**
             * Url
             * @description YouTube or YouTube Music playlist, album, or single track URL
             * @example https://music.youtube.com/playlist?list=OLAK5uy_...
             * @example https://www.youtube.com/watch?v=VIDEO_ID
             */
            url: string;
            /** @description Audio format for downloads. Uses server default if not set. */
            audio_format?: components["schemas"]["AudioCodec"] | null;
            /**
             * Max Items
             * @description Maximum number of tracks to download
             */
            max_items?: number | null;
        };
        /**
         * ErrorResponse
         * @description Standard error response format.
         */
        ErrorResponse: {
            /** Error */
            error: string;
            /** Message */
            message: string;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * HealthResponse
         * @description Health check response model.
         */
        HealthResponse: {
            /**
             * Status
             * @constant
             */
            status: "healthy";
        };
        /**
         * Job
         * @description A background sync job.
         */
        Job: {
            /** Id */
            id: string;
            /** Url */
            url: string;
            /** @default opus */
            audio_format: components["schemas"]["AudioCodec"];
            /** Max Items */
            max_items?: number | null;
            /** @default pending */
            status: components["schemas"]["JobStatus"];
            /**
             * Progress
             * @default 0
             */
            progress: number;
            content_info?: components["schemas"]["ContentInfo"] | null;
            download_stats?: components["schemas"]["PhaseStats"] | null;
            /**
             * Created At
             * Format: date-time
             */
            created_at?: string;
            /** Started At */
            started_at?: string | null;
            /** Completed At */
            completed_at?: string | null;
        };
        /**
         * JobCreatedResponse
         * @description Response when a job is created.
         */
        JobCreatedResponse: {
            /** Id */
            id: string;
            /**
             * Message
             * @default Job created
             * @constant
             */
            message: "Job created";
        };
        /**
         * JobStatus
         * @description Status of a background job.
         * @enum {string}
         */
        JobStatus: "pending" | "fetching_info" | "downloading" | "importing" | "completed" | "failed" | "cancelled";
        /**
         * JobsResponse
         * @description Response for listing jobs.
         */
        JobsResponse: {
            /** Jobs */
            jobs: components["schemas"]["Job"][];
        };
        /**
         * LogEntry
         * @description Structured log entry sent to frontend via SSE.
         *
         *     Each log line from the backend is serialized as JSON using this schema.
         *     The frontend parses these entries and applies theme-aware styling.
         *
         *     The `entry_type` field enables discriminated union pattern matching
         *     in TypeScript for exhaustive type narrowing.
         * @example {
         *       "entry_type": "phase",
         *       "level": "INFO",
         *       "message": "Extracting metadata from playlist",
         *       "phase": "extracting",
         *       "phase_num": 1,
         *       "timestamp": "11:09:53"
         *     }
         * @example {
         *       "current": 1,
         *       "entry_type": "progress",
         *       "event_type": "track_download",
         *       "level": "INFO",
         *       "message": "Queen - Bohemian Rhapsody",
         *       "timestamp": "11:09:54",
         *       "total": 10,
         *       "track_artist": "Queen",
         *       "track_title": "Bohemian Rhapsody"
         *     }
         * @example {
         *       "entry_type": "stats",
         *       "level": "INFO",
         *       "message": "Downloads complete",
         *       "stats": {
         *         "failed": 0,
         *         "skipped_by_reason": {
         *           "file_exists": 2
         *         },
         *         "stats_type": "download",
         *         "success": 8
         *       },
         *       "timestamp": "11:09:55"
         *     }
         */
        LogEntry: {
            /**
             * Entry Type
             * @description Entry type for discriminated union matching
             * @default default
             * @enum {string}
             */
            entry_type: "header" | "phase" | "stats" | "progress" | "status" | "file" | "default";
            /**
             * Timestamp
             * @description Log timestamp in HH:MM:SS format
             */
            timestamp: string;
            /**
             * Level
             * @description Log level: DEBUG, INFO, WARNING, ERROR
             */
            level: string;
            /**
             * Message
             * @description Human-readable log message
             */
            message: string;
            /**
             * Phase
             * @description Current operation phase: extracting, downloading, composing
             */
            phase?: string | null;
            /**
             * Phase Num
             * @description Phase number (1, 2, 3)
             */
            phase_num?: number | null;
            /**
             * Event Type
             * @description Specific event type for granular tracking
             */
            event_type?: string | null;
            /**
             * Current
             * @description Current item index in progress (0-indexed)
             */
            current?: number | null;
            /**
             * Total
             * @description Total number of items to process
             */
            total?: number | null;
            /**
             * Status
             * @description Operation result status
             */
            status?: ("success" | "skipped" | "failed") | null;
            /** @description Aggregate statistics for batch operations */
            stats?: components["schemas"]["LogStats"] | null;
            /**
             * File Path
             * @description Path to generated or downloaded file
             */
            file_path?: string | null;
            /**
             * File Type
             * @description Type of file: m3u, cover, audio
             */
            file_type?: string | null;
            /**
             * Track Title
             * @description Track title being processed
             */
            track_title?: string | null;
            /**
             * Track Artist
             * @description Track artist name
             */
            track_artist?: string | null;
            /**
             * Header
             * @description Section header text for visual separation
             */
            header?: string | null;
        };
        /**
         * LogStats
         * @description Statistics for batch operations.
         *
         *     Uses a discriminator field (stats_type) for frontend type narrowing,
         *     and dictionary-based skip reason counts for scalability.
         *
         *     Attributes:
         *         stats_type: Discriminator indicating extraction or download stats.
         *         success: Number of successful operations.
         *         failed: Number of failed operations.
         *         skipped_by_reason: Count of skipped items by reason.
         */
        LogStats: {
            /**
             * Stats Type
             * @description Type of stats: 'extraction' or 'download'
             * @enum {string}
             */
            stats_type: "extraction" | "download";
            /**
             * Success
             * @default 0
             */
            success: number;
            /**
             * Failed
             * @default 0
             */
            failed: number;
            /**
             * Skipped By Reason
             * @description Count of skipped items by reason
             */
            skipped_by_reason?: {
                [key: string]: number;
            };
        };
        /**
         * PhaseStats
         * @description Statistics for a processing phase (extraction or download).
         *
         *     Uses dictionary-based skip reason counts for scalability.
         *     Adding new skip reasons only requires updating the SkipReason enum.
         *
         *     Attributes:
         *         success: Number of successfully processed items.
         *         failed: Number of failed items.
         *         skipped_by_reason: Count of skipped items by reason.
         *
         *     Example:
         *         >>> stats = PhaseStats(
         *         ...     success=8,
         *         ...     failed=1,
         *         ...     skipped_by_reason={SkipReason.FILE_EXISTS: 2}
         *         ... )
         *         >>> stats.skipped  # 2
         *         >>> stats.total    # 11
         *         >>> stats.success_rate  # 72.7...
         */
        PhaseStats: {
            /**
             * Success
             * @default 0
             */
            success: number;
            /**
             * Failed
             * @default 0
             */
            failed: number;
            /** Skipped By Reason */
            skipped_by_reason?: {
                [key: string]: number;
            };
        };
        /**
         * SkipReason
         * @description Reason why a track was skipped.
         *
         *     Used in both extraction and download phases:
         *     - Extraction: UNSUPPORTED_VIDEO_TYPE, NO_VIDEO_ID, REGION_UNAVAILABLE,
         *       NO_ALBUM_MATCH
         *     - Download: FILE_EXISTS
         * @enum {string}
         */
        SkipReason: "file_exists" | "unsupported_video_type" | "no_video_id" | "region_unavailable" | "no_album_match";
        /**
         * SyncAllResponse
         * @description Response when sync jobs are created for all playlists.
         */
        SyncAllResponse: {
            /** Job Ids */
            job_ids: string[];
            /** Message */
            message: string;
        };
        /**
         * SyncConfigResponse
         * @description Response for sync configuration.
         */
        SyncConfigResponse: {
            /** Enabled */
            enabled: boolean;
            /** Interval Minutes */
            interval_minutes: number;
        };
        /**
         * SyncJobResponse
         * @description Response when a sync job is created.
         */
        SyncJobResponse: {
            /** Job Id */
            job_id: string;
            /**
             * Message
             * @default Sync job created
             */
            message: string;
        };
        /**
         * SyncStatusResponse
         * @description Response for scheduler status.
         */
        SyncStatusResponse: {
            /** Scheduler Running */
            scheduler_running: boolean;
            config: components["schemas"]["SyncConfigResponse"];
            /** Playlist Count */
            playlist_count: number;
            /** Enabled Playlist Count */
            enabled_playlist_count: number;
        };
        /**
         * SyncedPlaylistResponse
         * @description Response for a synced playlist.
         */
        SyncedPlaylistResponse: {
            /** Id */
            id: string;
            /** Url */
            url: string;
            /** Name */
            name: string;
            /** Thumbnail Url */
            thumbnail_url?: string | null;
            /** Enabled */
            enabled: boolean;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Last Job Id */
            last_job_id?: string | null;
            /** Last Sync At */
            last_sync_at?: string | null;
        };
        /**
         * SyncedPlaylistsResponse
         * @description Response for listing synced playlists.
         */
        SyncedPlaylistsResponse: {
            /** Playlists */
            playlists: components["schemas"]["SyncedPlaylistResponse"][];
        };
        /**
         * UpdatePlaylistRequest
         * @description Request to update a synced playlist.
         */
        UpdatePlaylistRequest: {
            /**
             * Name
             * @description New display name
             */
            name?: string | null;
            /**
             * Enabled
             * @description Whether to include in scheduled syncs
             */
            enabled?: boolean | null;
        };
        /**
         * UpdateSyncConfigRequest
         * @description Request to update sync configuration.
         */
        UpdateSyncConfigRequest: {
            /**
             * Enabled
             * @description Master switch for scheduled syncing
             */
            enabled?: boolean | null;
            /**
             * Interval Minutes
             * @description Minutes between sync runs (5-10080)
             */
            interval_minutes?: number | null;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    health_check_api_health_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HealthResponse"];
                };
            };
        };
    };
    list_jobs_api_jobs_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobsResponse"];
                };
            };
        };
    };
    create_job_api_jobs_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateJobRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["JobCreatedResponse"];
                };
            };
            /** @description Queue is full */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    clear_jobs_api_jobs_delete: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ClearJobsResponse"];
                };
            };
        };
    };
    cancel_job_api_jobs__job_id__cancel_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CancelJobResponse"];
                };
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Job already finished */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_job_api_jobs__job_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Job not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Cannot delete running job */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_log_history_api_logs_history_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LogEntry"][];
                };
            };
        };
    };
    stream_logs_api_logs_sse_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    cookies_status_api_cookies_status_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CookiesStatusResponse"];
                };
            };
        };
    };
    upload_cookies_api_cookies_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CookiesUploadRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CookiesUploadResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_cookies_api_cookies_delete: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CookiesUploadResponse"];
                };
            };
        };
    };
    list_playlists_api_sync_playlists_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncedPlaylistsResponse"];
                };
            };
        };
    };
    add_playlist_api_sync_playlists_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AddPlaylistRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AddPlaylistResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_playlist_api_sync_playlists__playlist_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                playlist_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncedPlaylistResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    delete_playlist_api_sync_playlists__playlist_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                playlist_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    update_playlist_api_sync_playlists__playlist_id__patch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                playlist_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdatePlaylistRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncedPlaylistResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    sync_playlist_api_sync_playlists__playlist_id__sync_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                playlist_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncJobResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    sync_all_api_sync_run_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncAllResponse"];
                };
            };
        };
    };
    get_config_api_sync_config_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncConfigResponse"];
                };
            };
        };
    };
    update_config_api_sync_config_patch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateSyncConfigRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncConfigResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    get_status_api_sync_status_get: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SyncStatusResponse"];
                };
            };
        };
    };
}
