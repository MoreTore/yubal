# YouTube Music Playlist Metadata Enrichment Implementation Guide

## Overview

This document provides a complete implementation guide for enriching playlist track metadata using the `ytmusicapi` library. The goal is to obtain album/artist metadata for music videos that yt-dlp cannot access.

## Problem Statement

When importing playlists from YouTube Music:
- **Album tracks** (auto-generated by distributors) have full metadata (artist, album, year)
- **Music videos** (manually uploaded) have NO metadata - yt-dlp returns empty album/artist fields
- YouTube Music's web UI shows metadata for both types, but this is **client-side enrichment** - the raw API doesn't return it

### Research Findings

| Source | Title | Artists | Album |
|--------|-------|---------|-------|
| yt-dlp (music video) | Messy | None | None |
| ytmusicapi `get_playlist()` | Clean | Structured | None for videos |
| ytmusicapi `search(filter='songs')` | Clean | Structured | **Full** |

**Key insight**: `get_playlist()` gives clean title/artists for ALL tracks. For tracks missing album, `search()` can find the album version with full metadata.

## Solution: Search-Based Enrichment

### Flow

```
1. Fetch playlist metadata via ytmusicapi.get_playlist(playlist_id)
   - Returns clean title, artists for ALL tracks
   - Returns album for album-tracks, None for music videos
   - Returns isAvailable=False for non-music content

2. For each track:
   if not track.isAvailable:
       skip (non-music content like gaming streams)

   if track.album:
       use existing metadata (already has album)

   else:  # Music video - needs enrichment
       results = ytmusicapi.search(f"{artist} {title}", filter='songs', limit=1)
       if results[0].artist matches track.artist:
           track.album = results[0].album

3. Pass enriched metadata to downloader for embedding
```

### User Decisions (from research phase)

- **When to enrich**: Only for playlist imports (keeps album flow unchanged)
- **Mismatch handling**: Best effort (accept first match if artist matches)

---

## Implementation Details

### 1. Add Dependency

**File**: `pyproject.toml`

```toml
dependencies = [
  # ... existing deps
  "ytmusicapi>=1.9.0",  # YouTube Music API for playlist metadata enrichment
]
```

After editing, run:
```bash
uv sync
```

---

### 2. Create MetadataEnricher Service

**File**: `yubal/services/metadata_enricher.py`

```python
"""YouTube Music metadata enrichment using ytmusicapi."""

import time
from dataclasses import dataclass

from loguru import logger
from ytmusicapi import YTMusic


@dataclass
class EnrichedTrack:
    """Track with enriched metadata from YouTube Music."""

    video_id: str
    title: str
    artist: str
    album: str | None
    is_available: bool  # False = non-music content (gaming, vlogs)


class MetadataEnricher:
    """Enriches playlist track metadata using YouTube Music API.

    Uses ytmusicapi to:
    1. Get clean title/artist from get_playlist()
    2. Search for album info for music videos that lack it

    This is only used for playlist imports, not album imports.
    """

    def __init__(self, request_delay: float = 0.5):
        """Initialize the enricher.

        Args:
            request_delay: Delay between search requests to avoid rate limiting.
                          Set to 0 for testing.
        """
        self.yt = YTMusic()  # Works without authentication
        self.request_delay = request_delay

    def enrich_playlist(self, playlist_id: str) -> list[EnrichedTrack]:
        """Fetch and enrich all tracks in a playlist.

        Args:
            playlist_id: YouTube Music playlist ID (not full URL).
                        Example: "PLbE6wFkAlDUeDUu98GuzkCWm60QjYvagQ"

        Returns:
            List of EnrichedTrack with album info where available.
        """
        logger.info("Enriching playlist metadata: {}", playlist_id)

        playlist = self.yt.get_playlist(playlist_id)
        tracks = playlist.get("tracks", [])
        enriched: list[EnrichedTrack] = []
        search_count = 0

        for track in tracks:
            video_id = track.get("videoId")
            is_available = track.get("isAvailable", False)

            # Non-music content (gaming, vlogs) - skip enrichment
            if not is_available or not video_id:
                enriched.append(EnrichedTrack(
                    video_id=video_id or "",
                    title=track.get("title", ""),
                    artist=self._get_artist(track),
                    album=None,
                    is_available=False,
                ))
                continue

            title = track.get("title", "")
            artist = self._get_artist(track)

            # Get album from playlist data (works for album tracks)
            album = None
            if track.get("album"):
                album = track["album"].get("name")

            # If missing album, search for it (music videos need this)
            if not album and artist and title:
                # Rate limit to be safe (ytmusicapi doesn't document limits)
                if search_count > 0 and self.request_delay > 0:
                    time.sleep(self.request_delay)

                album = self._search_album(artist, title)
                search_count += 1

            enriched.append(EnrichedTrack(
                video_id=video_id,
                title=title,
                artist=artist,
                album=album,
                is_available=True,
            ))

        logger.info(
            "Enriched {} tracks ({} searches performed)",
            len(enriched),
            search_count,
        )
        return enriched

    def _get_artist(self, track: dict) -> str:
        """Extract primary artist name from track data."""
        artists = track.get("artists", [])
        if artists and artists[0]:
            return artists[0].get("name", "")
        return ""

    def _search_album(self, artist: str, title: str) -> str | None:
        """Search for album version of a track (best effort).

        Args:
            artist: Primary artist name
            title: Track title

        Returns:
            Album name if found and artist matches, None otherwise.
        """
        try:
            query = f"{artist} {title}"
            results = self.yt.search(query, filter="songs", limit=1)

            if not results:
                logger.debug("No search results for: {}", query)
                return None

            result = results[0]

            # Verify artist matches (avoid wrong tracks)
            result_artists = [a.get("name", "") for a in result.get("artists", [])]
            if artist not in result_artists:
                logger.debug(
                    "Artist mismatch for '{}': expected '{}', got {}",
                    title, artist, result_artists,
                )
                return None

            album = result.get("album", {})
            if album:
                album_name = album.get("name")
                logger.debug("Found album '{}' for '{}'", album_name, title)
                return album_name

            return None

        except Exception as e:
            logger.warning("Search failed for '{}': {}", title, e)
            return None


def extract_playlist_id(url: str) -> str | None:
    """Extract playlist ID from a YouTube Music URL.

    Args:
        url: Full YouTube Music URL

    Returns:
        Playlist ID or None if not a playlist URL.

    Examples:
        >>> extract_playlist_id("https://music.youtube.com/playlist?list=PLxxx")
        "PLxxx"
        >>> extract_playlist_id("https://music.youtube.com/watch?v=xxx")
        None
    """
    from urllib.parse import parse_qs, urlparse

    parsed = urlparse(url)

    # Handle both music.youtube.com and youtube.com
    if "youtube" not in parsed.netloc:
        return None

    query = parse_qs(parsed.query)

    # Get list parameter
    list_param = query.get("list", [])
    if list_param:
        return list_param[0]

    return None


def is_playlist_url(url: str) -> bool:
    """Check if URL is a YouTube Music playlist (not album).

    Albums have playlist IDs starting with 'OLAK5uy_'.
    User playlists start with 'PL' or 'RDTMAK5uy_' (radio mixes).

    Args:
        url: YouTube Music URL

    Returns:
        True if this is a playlist that should be enriched.
    """
    playlist_id = extract_playlist_id(url)
    if not playlist_id:
        return False

    # Albums start with OLAK5uy_ - don't enrich these
    if playlist_id.startswith("OLAK5uy_"):
        return False

    return True
```

---

### 3. Integrate into Sync Service

**File**: `yubal/services/sync.py`

The integration point is `SyncService.sync_album()`. For playlist imports, we need to:
1. Check if URL is a playlist (not album)
2. Enrich metadata before download
3. Pass enriched metadata to downloader

#### Option A: Minimal Integration (Recommended)

Add a new method `sync_playlist()` that handles the enrichment flow separately:

```python
# Add to imports
from yubal.services.metadata_enricher import (
    MetadataEnricher,
    EnrichedTrack,
    is_playlist_url,
    extract_playlist_id,
)

# Add to SyncService class
def sync_playlist(
    self,
    url: str,
    job_id: str,
    progress_callback: ProgressCallback | None = None,
    cancel_check: CancelCheck | None = None,
) -> SyncResult:
    """
    Download and tag a playlist with metadata enrichment.

    Similar to sync_album() but enriches metadata for music videos
    using YouTube Music API.
    """
    playlist_id = extract_playlist_id(url)
    if not playlist_id:
        return SyncResult(
            success=False,
            error="Invalid playlist URL",
        )

    # Create temp subfolder per job
    job_temp_dir = self.temp_dir / job_id
    job_temp_dir.mkdir(parents=True, exist_ok=True)

    try:
        # Phase 0: Enrich metadata (new step)
        if progress_callback:
            progress_callback(
                ProgressEvent(
                    step=ProgressStep.FETCHING_INFO,
                    message="Enriching playlist metadata...",
                    progress=0.0,
                )
            )

        enricher = MetadataEnricher()
        enriched_tracks = enricher.enrich_playlist(playlist_id)

        # Filter out unavailable tracks
        available_tracks = [t for t in enriched_tracks if t.is_available]

        if not available_tracks:
            return SyncResult(
                success=False,
                error="No available tracks in playlist",
            )

        # Continue with regular download flow...
        # Pass enriched_tracks to downloader for metadata embedding
        # (See downloader integration below)

    except Exception as e:
        return SyncResult(
            success=False,
            error=str(e),
        )
    finally:
        if job_temp_dir.exists():
            shutil.rmtree(job_temp_dir, ignore_errors=True)
```

#### Option B: Smart Detection

Modify `sync_album()` to auto-detect playlist vs album:

```python
def sync_album(self, url: str, ...):
    # Auto-detect if playlist needs enrichment
    if is_playlist_url(url):
        return self.sync_playlist(url, ...)

    # Existing album flow...
```

---

### 4. Update Downloader to Accept Enriched Metadata

**File**: `yubal/services/downloader.py`

The downloader needs to accept enriched track metadata and use it instead of yt-dlp's metadata.

#### Add EnrichedTrack Parameter

```python
from yubal.services.metadata_enricher import EnrichedTrack

def download_album(
    self,
    url: str,
    output_dir: Path,
    enriched_tracks: list[EnrichedTrack] | None = None,  # NEW
    progress_callback: ProgressCallback | None = None,
    cancel_check: CancelCheck | None = None,
) -> DownloadResult:
    """Download with optional enriched metadata."""
    ...
```

#### Override Metadata in yt-dlp Options

When enriched tracks are provided, we need to tell yt-dlp to use our metadata instead. This can be done via the `MetadataParser` postprocessor:

```python
def _get_ydl_opts(
    self,
    output_dir: Path,
    progress_hook: Callable,
    enriched_tracks: list[EnrichedTrack] | None = None,  # NEW
) -> dict[str, Any]:
    """Build yt-dlp options with optional enriched metadata."""

    # Build metadata override mapping: video_id -> metadata
    metadata_map = {}
    if enriched_tracks:
        metadata_map = {
            t.video_id: {
                "title": t.title,
                "artist": t.artist,
                "album": t.album,
            }
            for t in enriched_tracks
            if t.is_available
        }

    # If we have enriched metadata, add custom metadata actions
    if metadata_map:
        # This requires a custom postprocessor approach
        # See alternative: post-download metadata patching
        pass

    # Rest of existing options...
```

#### Alternative: Post-Download Metadata Patching

A simpler approach is to patch metadata AFTER download using mutagen:

```python
# In sync.py, after download completes:

from mutagen import File as MutagenFile
from mutagen.mp3 import MP3
from mutagen.mp4 import MP4
from mutagen.oggopus import OggOpus

def patch_metadata(
    audio_files: list[Path],
    enriched_tracks: list[EnrichedTrack],
) -> None:
    """Patch audio file metadata with enriched data.

    Args:
        audio_files: Downloaded audio files (in playlist order)
        enriched_tracks: Enriched metadata (in same order)
    """
    for i, (file, track) in enumerate(zip(audio_files, enriched_tracks)):
        if not track.is_available or not track.album:
            continue

        try:
            audio = MutagenFile(str(file), easy=True)
            if audio is None:
                continue

            # Update metadata
            audio["title"] = track.title
            audio["artist"] = track.artist
            if track.album:
                audio["album"] = track.album

            audio.save()
            logger.debug("Patched metadata for: {}", file.name)

        except Exception as e:
            logger.warning("Failed to patch {}: {}", file.name, e)
```

---

## Considerations

### Rate Limiting

- ytmusicapi doesn't document rate limits
- Default: 0.5s delay between search requests
- For a 100-track playlist, enrichment adds ~50s
- Can be disabled for testing with `request_delay=0`

### Matching Accuracy (Best Effort)

The search approach has limitations:
- May get wrong album for covers/remixes
- Requires artist name match as validation
- Some tracks may not have album versions

This is acceptable for playlist imports where some metadata is better than none.

### Non-Music Videos

Videos like gaming streams, vlogs, etc. won't have music metadata:
- `isAvailable=False` in ytmusicapi response
- Gracefully skipped during enrichment
- Will still download (just without enriched metadata)

### URL Detection

```python
# Album URLs (don't enrich - already have metadata):
# https://music.youtube.com/playlist?list=OLAK5uy_xxx

# Playlist URLs (enrich these):
# https://music.youtube.com/playlist?list=PLxxx
# https://music.youtube.com/playlist?list=RDTMAK5uy_xxx (radio mixes)
```

---

## Testing

### Manual Test

```python
# Test enricher standalone
from yubal.services.metadata_enricher import MetadataEnricher

enricher = MetadataEnricher(request_delay=0)  # Disable delay for testing

# Test playlist with music videos
tracks = enricher.enrich_playlist("PL4fGSI1pDJn6sMPCoD7PdSlEgyUylgxuT")

for t in tracks[:5]:
    print(f"{t.title} - {t.artist} [{t.album or 'NO ALBUM'}]")
```

### Unit Tests

**File**: `tests/test_metadata_enricher.py`

```python
import pytest
from yubal.services.metadata_enricher import (
    MetadataEnricher,
    extract_playlist_id,
    is_playlist_url,
)


class TestExtractPlaylistId:
    def test_playlist_url(self):
        url = "https://music.youtube.com/playlist?list=PLxxx"
        assert extract_playlist_id(url) == "PLxxx"

    def test_album_url(self):
        url = "https://music.youtube.com/playlist?list=OLAK5uy_xxx"
        assert extract_playlist_id(url) == "OLAK5uy_xxx"

    def test_watch_url(self):
        url = "https://music.youtube.com/watch?v=xxx"
        assert extract_playlist_id(url) is None


class TestIsPlaylistUrl:
    def test_user_playlist(self):
        assert is_playlist_url(
            "https://music.youtube.com/playlist?list=PLxxx"
        ) is True

    def test_album_not_playlist(self):
        assert is_playlist_url(
            "https://music.youtube.com/playlist?list=OLAK5uy_xxx"
        ) is False

    def test_radio_mix(self):
        assert is_playlist_url(
            "https://music.youtube.com/playlist?list=RDTMAK5uy_xxx"
        ) is True


@pytest.mark.integration
class TestMetadataEnricher:
    """Integration tests that hit the real YouTube Music API."""

    def test_enrich_playlist(self):
        enricher = MetadataEnricher(request_delay=0.5)

        # Use a known public playlist
        tracks = enricher.enrich_playlist("PLbE6wFkAlDUeDUu98GuzkCWm60QjYvagQ")

        assert len(tracks) > 0
        assert all(t.title for t in tracks if t.is_available)
        assert all(t.artist for t in tracks if t.is_available)
```

---

## Files Summary

| File | Action | Description |
|------|--------|-------------|
| `pyproject.toml` | Edit | Add `ytmusicapi>=1.9.0` dependency |
| `yubal/services/metadata_enricher.py` | Create | New enrichment service |
| `yubal/services/sync.py` | Edit | Add `sync_playlist()` method |
| `yubal/services/downloader.py` | Edit | Accept enriched metadata (optional) |
| `tests/test_metadata_enricher.py` | Create | Unit/integration tests |

---

## Why ytmusicapi?

| Approach | Verdict |
|----------|---------|
| Scraping YouTube Music UI | Fragile, ToS violation |
| YouTube Data API v3 | No music-specific metadata |
| MusicBrainz lookup | Requires separate matching, slower |
| **ytmusicapi** | Clean API, works unauthenticated, returns structured data |

The library is actively maintained (1.9k+ stars, regular updates) and uses the same InnerTube API as YouTube Music's web client.
